<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    iOS KVC/KVO小结 丨
    

    Peng&#39;s blog
  </title>

  
  <link rel="shortcut icon" href="/images/favicon.ico">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Peng&#39;s blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">iOS KVC/KVO小结</div>
  <div class="post-meta">
    <div class="date">2020 April 16th</div>
    <div class="tags">
      
      <div class="tag-item">基础</div>
      
      <div class="tag-item">OC</div>
      
    </div>
  </div>
  

  <main class="post-content"><p>本文对 KVC、KVO 相关知识进行全面的整理总结，介绍了相关的基本概念、使用方法、注意事项、实现原理等。后续如有更深的理解会继续整理总结。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>KVC ( <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html">Key-value coding</a> 键值编码 ) 是一种由 NSKeyValueCoding 非正式协议启用的机制，对象采用该机制提供对其属性的间接访问。当对象符合键值编码时，通过字符串名称访问对象属性。<br>键值编码的机制也是<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW4">其他 Cocoa 框架的基础</a>，例如 KVO。  </p>
<p>KVO ( <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">Key-value observing</a> 键值观察 )  这一机制基于 NSKeyValueObserving 非正式协议，Cocoa 通过这个协议为所有遵守协议的对象提供了一种自动化的属性观察能力。对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的 KVO 接口方法，来通知观察者。KVO 是 Cocoa 框架使用观察者模式的一种途径。</p>
<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><p>KVC 提供了简洁的方法，来访问对象属性。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;  </span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>上面两个方法，分别是对应于 getter 访问器的 valueForKey: 和对应于 setter 访问器的 setValue:forKey: 。  </p>
<ul>
<li>valueForKey: 首先查找以键 -getKey、 -key 或 -isKey 命名的 getter 方法。如果不存在 getter 方法（假设没有通过@synthesize提供存取方法），它将在对象内部查找名为 _key 或 key 的实例变量。如果最后没找调用 valueForUndefinedKey: 方法。  </li>
<li>setValue:forKey: 首先查找以键  -setKey、 -_setKey 命名的 setter 方法，如果不存在 setter 方法，它将在类中查找名为 _key 或 key 的实例变量。如果最后没找到则调用 setValue:forUndefinedKey: 方法。</li>
</ul>
<p>例如某对象有属性 name、age，我们就可使用上面两个方法进行访问、设置属性值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line"></span><br><span class="line">[obj setValue:@&quot;jone&quot; forKey:@&quot;name&quot;];</span><br><span class="line">[obj setValue:@(10) forKey:@&quot;age&quot;];</span><br><span class="line">id stAge = [obj valueForKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure>
<p>对于属性是基本的数据类型时 (int, CGFloat)  是放入 NSNumber 或 NSValue 中来设置的。<br>相比直接访问，KVC的效率会稍低一点，所以只有当你非常需要它提供的可扩展性时才使用它。    </p>
<h4 id="其他使用方法"><a href="#其他使用方法" class="headerlink" title="其他使用方法"></a>其他使用方法</h4><p>1、属性的属性的访问<br>KVC 还提供了访问属性的属性的操作方法：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<p>例如下面两个类：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Teacher : NSObject</span><br><span class="line">@property (nonatomic, strong) Student *student;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//路径访问</span><br><span class="line">[teacher setValue:@&quot;haha&quot; forKeyPath:@&quot;student.name&quot;];</span><br><span class="line">id name = [teacher valueForKeyPath:@&quot;student.name&quot;];</span><br></pre></td></tr></table></figure>

<p>2、多值访问<br>同时访问多个属性的方法：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[obj setValuesForKeysWithDictionary:@&#123;@&quot;name&quot;:@&quot;Tom&quot;, @&quot;age&quot;:@(2)&#125;];</span><br><span class="line">NSDictionary *values = [obj dictionaryWithValuesForKeys:@[@&quot;name&quot;,@&quot;age&quot;]];</span><br></pre></td></tr></table></figure>

<p>3、集合属性<br>KVC 同样适用于集合对象，可以通过 valueForKey: 和 setValue:forKey:（或它们的键路径方式）获取或设置集合对象。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//@property (nonatomic, copy) NSArray&lt;Student *&gt; *students;</span><br><span class="line">id array = [teacher valueForKeyPath:@&quot;students.name&quot;];</span><br><span class="line">//返回数组，包含属性 student.name</span><br></pre></td></tr></table></figure>

<p>KVC 还提供了接口  mutableArrayValueForKey:、  mutableSetValueForKey: 来操作集合类型的属性。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//@property (nonatomic, copy) NSArray *items;</span><br><span class="line"></span><br><span class="line">obj.items = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;];</span><br><span class="line">NSMutableArray *items = [obj mutableArrayValueForKey:@&quot;items&quot;];</span><br><span class="line">[items addObject:@&quot;d&quot;];</span><br><span class="line">//添加后，同时也改变了 obj.items</span><br></pre></td></tr></table></figure>

<p>4、运算符<br>运算符是一个特殊的 Key Path，可以作为参数传递给 valueForKeyPath：方法，注意只能是这个方法，如果传给了valueForKey:方法会崩溃。<br>运算符是一个以@开头的特殊字符串：<br><img src="/images/2020/kvc-1.jpg">  </p>
<ul>
<li>简单集合运算符有 @avg，@count，@max，@min，@sum  </li>
<li>对象运算符，比集合运算符稍微复杂，能以数组的方式返回指定的内容，有两种 @distinctUnionOfObjects、@unionOfObjects ，前者会去除重复的以后返回，后者直接返回。  </li>
<li>Array和Set操作符，这种情况更复杂了，说的是集合中包含集合的情况，有三种 @distinctUnionOfArrays、@unionOfArrays、@distinctUnionOfSets，前两个针对的集合是Arrays，后一个针对的集合是Sets。因为Sets中的元素本身就是唯一的，所以没有对应的 @unionOfSets 运算符。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *value = [teacher valueForKeyPath:@&quot;students.@max.age&quot;];</span><br><span class="line">NSNumber *count = [teacher valueForKeyPath:@&quot;students.@count&quot;];</span><br><span class="line"></span><br><span class="line"> NSArray * array = [teacher valueForKeyPath:@&quot;students.@distinctUnionOfObjects.age&quot;];</span><br><span class="line"> </span><br><span class="line"> NSMutableArray *someStudents = [NSMutableArray array];</span><br><span class="line">[someStudents addObject:@[st0, st1, st2]];</span><br><span class="line">[someStudents addObject:@[st3, st4]];</span><br><span class="line">id value = [someStudents valueForKeyPath:@&quot;@distinctUnionOfArrays.age&quot;];</span><br></pre></td></tr></table></figure>


<h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>1、找不到对应的 key<br>当调用 setValue:forKey: 或者 valueForKey: 找不到对应 key 命名的属性时，就会 NSUnknownKeyException 异常崩溃，可以在对象里重写下面两个方法，防止崩溃。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)valueForUndefinedKey:(NSString *)key &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、将不是对象类型的属性设置为 nil<br>将对象赋值为 nil 这是可以的相当于把对象置空。但是当使用 setValue:forKey: 将非对象类型的属性值( int、CGFloat、结构体等)，设置为 nil 时会 NSInvalidArgumentException 异常崩溃。我们可以重写方法 setNilValueForKey: 处理设置为 nil 的情况：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//@property (nonatomic, assign) int age;</span><br><span class="line">//[obj setValue:nil forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">- (void)setNilValueForKey:(NSString *)key &#123;</span><br><span class="line">    if ([key isEqualToString:@&quot;age&quot;]) &#123;</span><br><span class="line">        [self setValue:@(0) forKey:@&quot;age&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super setNilValueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>


<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>KVO 是 Cocoa 框架使用观察者模式的一种途径。 KVC 是 KVO 技术实现的基础 ，参与 KVO 的对象需要符合 KVC 的要求和存取方法，也可以手动实现观察者通知。  </p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>1、添加观察：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:(__bridge void *)self];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>options 回调选项，NSKeyValueObservingOptionOld 表示获取旧值，NSKeyValueObservingOptionNew 表示获取新值，NSKeyValueObservingOptionInitial 表示在添加观察的时候就立马响应一个回调，NSKeyValueObservingOptionPrior 表示在被观察属性变化前后都回调一次。  </p>
</li>
<li><p>context  可以是 C 指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。</p>
</li>
</ul>
<p>2、观察回调：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;observe  key = %@, obj = %@, change = %@&quot;, keyPath, object, change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">observe  key = name, obj = &lt;Student: 0x6000016c6e80&gt;, change = &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = Tony;</span><br><span class="line">    old = Tom;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>change 是一个字典，对应的键有：NSKeyValueChangeKindKey、NSKeyValueChangeNewKey、NSKeyValueChangeOldKey、NSKeyValueChangeIndexesKey、NSKeyValueChangeNotificationIsPriorKey。  </p>
<p>NSKeyValueChangeKindKey 指明了变更类型，设置、插入、移除、替换：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">   NSKeyValueChangeSetting = 1,</span><br><span class="line">   NSKeyValueChangeInsertion = 2,</span><br><span class="line">   NSKeyValueChangeRemoval = 3,</span><br><span class="line">   NSKeyValueChangeReplacement = 4</span><br><span class="line">&#125;;</span><br><span class="line">typedef NSUInteger NSKeyValueChange;</span><br></pre></td></tr></table></figure>
<p>NSKeyValueChangeNotificationIsPriorKey 指明是变更前或变更后，触发的回调。  </p>
<p>3、移除观察：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj removeObserver:self forKeyPath:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>移除观察，和移除通知比较类似，需要在不用继续观察的时候移除它，比如在控制器的 dealloc 方法里面释放，注意重复移除会 crash。  </p>
<p>4、调试 KVO<br>可以打断点，在 lldb 中查看被观察对象的所有观察信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb po [obj observationInfo]</span><br></pre></td></tr></table></figure>
<p>这会打印出有关谁观察谁之类的很多信息。  </p>
<h4 id="KVO-兼容"><a href="#KVO-兼容" class="headerlink" title="KVO 兼容"></a>KVO 兼容</h4><p>有两种方法可以保证变更通知被发出。自动发送通知是 NSObject 提供的，并且一个类中的所有属性都默认支持，只要是符合 KVC 的。<br>手动变更通知需要些额外的代码，但也对通知发送提供了额外的控制。可以通过重写子类 automaticallyNotifiesObserversForKey: 方法的方式控制子类一些属性的自动通知。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    if ([key isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    if (![_name isEqualToString:name]) &#123;</span><br><span class="line">        [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">        _name = [name copy];</span><br><span class="line">        [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果一个操作导致多个键变化，需要嵌套变更通知</span><br><span class="line">- (void)setLastName:(NSString *)lastName &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;lastName&quot;];</span><br><span class="line">    [self willChangeValueForKey:@&quot;fullName&quot;];</span><br><span class="line">    _lastName = [lastName copy];</span><br><span class="line">    _fullName = [NSString stringWithFormat:@&quot;Title %@&quot;, lastName];</span><br><span class="line">    [self didChangeValueForKey:@&quot;fullName&quot;];</span><br><span class="line">    [self didChangeValueForKey:@&quot;lastName&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当观察某个对象的集合属性时，当直接使用 obj.mutableArray 添加、删除、替换元素时，不会触发观察回调，需要手动添加代码  willChange:valuesAtIndexes:forKey: 和 didChange:valuesAtIndexes:forKey: 来通知集合属性发生了变化。或者使用 KVC 来操作集合属性。如下例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//某类集合属性</span><br><span class="line">//@property (nonatomic, strong) NSMutableArray *myArray;</span><br><span class="line"></span><br><span class="line">//添加观察</span><br><span class="line">[obj addObserver:self forKeyPath:@&quot;myArray&quot; options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil];</span><br><span class="line"></span><br><span class="line">//变更集合时，手动通知观察者</span><br><span class="line">[self.obj willChange:NSKeyValueChangeRemoval valuesAtIndexes:[NSIndexSet indexSetWithIndex:0] forKey:@&quot;myArray&quot;];</span><br><span class="line">[self.obj.myArray removeObjectAtIndex:0];</span><br><span class="line">[self.obj didChange:NSKeyValueChangeRemoval valuesAtIndexes:[NSIndexSet indexSetWithIndex:0] forKey:@&quot;myArray&quot;];</span><br><span class="line"></span><br><span class="line">//或者使用 KVC 操作集合，会自动通知观察者</span><br><span class="line">NSMutableArray *array = [self.obj mutableArrayValueForKey:@&quot;myArray&quot;];</span><br><span class="line">[array removeObjectAtIndex:0];</span><br></pre></td></tr></table></figure>

<h4 id="注册从属键"><a href="#注册从属键" class="headerlink" title="注册从属键"></a>注册从属键</h4><p>某些情况下，一个属性的值取决于另一个对象中的一个或多个其他属性的值。如果一个属性的值发生更改，则还应标记派生属性的值以进行更改。<br>例如，fullName 取决于 firstName 和 lastName。当 firstName 或 lastName 发生改变时，必须通知观察 fullName 属性的程序，因为它们影响这个属性的值。<br>重写 keyPathsForValuesAffectingValueForKey 来指定 fullName 属性依赖于lastName和firstName。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)setLastName:(NSString *)lastName &#123;</span><br><span class="line">    _lastName = [lastName copy];</span><br><span class="line">    _fullName = [NSString stringWithFormat:@&quot;%@ %@&quot;, _firstName, lastName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重写指定 fullName 属性依赖于lastName</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//或者重写</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>KVO 是基于 runtime 运行时来实现的，当你观察了某个对象的属性，内部会生成一个该对象所属类的子类，中间类，然后重写被观察属性的 setter 方法，当然在重写的方法中会调用父类的 setter 方法从而不会影响框架使用者的逻辑，之后会将该对象的 isa 指针指向新创建的这个类，最后会重写 -(Class)class; 方法，让使用者通过 [obj class] 查看当前对象所属类的时候会返回其父类，使其看似没有改变什么，让你觉得不需要添加额外的代码，就能使用 KVO。<br>Apple 并不希望过多暴露 KVO 的实现细节。想要深究实现细节，<a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html">可查看文章</a><br>下面例子，通过 object_getClass() 方法查看观察前后的变化。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//object_getClass 获取 isa 指针指向的对象</span><br><span class="line">//object_setClass 更改对象的 isa 指针指向。将对象设置为别的类类型，返回原来的Class</span><br><span class="line">NSLog(@&quot;1 --- %p %@ %p&quot;, obj, object_getClass(obj), [obj methodForSelector:@selector(setName:)]);</span><br><span class="line"></span><br><span class="line">[obj addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:(__bridge void *)self];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;2 --- %p %@ %p&quot;, obj, object_getClass(obj), [obj methodForSelector:@selector(setName:)]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[self.obj removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">NSLog(@&quot;3 --- %p %@ %p&quot;, self.obj, object_getClass(self.obj), [self.obj methodForSelector:@selector(setName:)]);</span><br><span class="line"></span><br><span class="line">//1 --- 0x60000225cea0  AStudent 0x1067f72a0</span><br><span class="line">//2 --- 0x60000225cea0  NSKVONotifying_AStudent 0x7fff258e454b</span><br><span class="line">//3 --- 0x60000225cea0  AStudent 0x1067f72a0</span><br></pre></td></tr></table></figure>
<p>通过上面的打印结果可知，添加观察后，原本的类变成了 NSKVONotifying_AStudent，移除观察后又变回去了， setName: 方法也发生了变化。   </p>
<br>


<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wzzvictory/article/details/9674431">KVC&#x2F;KVO原理详解及编程指南</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/">Objective-C中的KVC和KVO</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7ea7d551fc69">透彻理解 KVO 观察者模式</a></p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>