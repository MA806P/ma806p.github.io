<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    RAC 丨
    

    Peng&#39;s blog
  </title>

  
  <link rel="shortcut icon" href="/images/favicon.ico">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Peng&#39;s blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">RAC</div>
  <div class="post-meta">
    <div class="date">2018 June 3rd</div>
    <div class="tags">
      
      <div class="tag-item">OC</div>
      
      <div class="tag-item">RAC</div>
      
    </div>
  </div>
  

  <main class="post-content"><p>本篇文章是用来记录一下有关 ReactiveCocoa 的学习笔记。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>（简称 RAC）是由 Github 开源的一个应用于 iOS 和 macOS 开发的新框架。RAC具有函数式编程和响应式编程的特性，可称其为函数响应式编程（FRP, Functional Reactive Programming）框架。</p>
<blockquote>
<p>“函数式编程”（programming paradigm）属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。<br>特点：<br>1、函数是”第一等公民”：函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。<br>2、函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。<br>3、函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。<br><br>例如，表达式(1 + 2) * 3 - 4，写成函数式语言：<br>subtract(multiply(add(1,2), 3), 4);<br>add(1,2).multiply(3).subtract(4);</p>
</blockquote>
<blockquote>
<p>“响应式编程”（Reactive Programming）是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。<br><br>例如，在命令式编程环境中，a &#x3D; b + c 表示将表达式的结果赋给 a，而之后改变 b 或 c 的值不会影响 a，只是一个瞬时的过程。但在响应式编程中，a 的值会随着 b 或 c 的更新而更新。</p>
</blockquote>
<p>函数响应式编程 FRP，正是在函数式编程的基础之上，增加了响应式的支持。FRP是基于异步事件流进行编程的一种编程范式。针对离散事件序列进行有效的封装，利用函数式编程的思想，满足响应式编程的需要。<br>RAC 是一个函数响应式编程框架，它给我们提供另外一套编码的思路与可能性，它能在宏观层面上提升代码易读性与稳定性。<br><br></p>
<h3 id="RAC-介绍"><a href="#RAC-介绍" class="headerlink" title="RAC 介绍"></a>RAC 介绍</h3><p>下面来介绍一下 ReactiveObjC 框架，有关 Swift 版本框架的可查看 <a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> or <a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveSwift">ReactiveSwift</a>。<br>在项目中导入框架：<br><img src="/images/2018/rac-1.png"></p>
<p>开始之前先看看相关类图，如下：<br><img src="/images/2018/rac-2.png" alt="ReactiveObjC"></p>
<p>RAC 主要由以下核心组件构成：</p>
<ul>
<li>信号源：RACStream 及其子类；</li>
<li>订阅者：RACSubscriber 的实现类及其子类；</li>
<li>调度器：RACScheduler 及其子类；</li>
<li>清洁工：RACDisposable 及其子类。<br>其中，信号源又是最核心的部分，其他组件都是围绕它运作的。</li>
</ul>
<p>对于一个应用来说，绝大部分的时间都是在等待某些事件的发生或响应某些状态的变化，比如用户的触摸事件、应用进入后台、网络请求成功刷新界面等等，而维护这些状态的变化，常常会使代码变得非常复杂，难以扩展。而 ReactiveCocoa 给出了一种非常好的解决方案，它使用信号来代表这些异步事件，提供了一种统一的方式来处理所有异步的行为，包括代理方法、block 回调、target-action 机制、通知、KVO 等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//代理方法</span><br><span class="line">[[self rac_signalForSelector:@selector(tableView:didSelectRowAtIndexPath:) </span><br><span class="line">    fromProtocol:@protocol(UITableViewDelegate)] </span><br><span class="line">    subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    //实现代理方法</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//target-action</span><br><span class="line">[[button rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">     subscribeNext:^(__kindof UIControl * _Nullable x) &#123;</span><br><span class="line">    //按钮点击</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//通知</span><br><span class="line">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:kNotificationName object:nil] </span><br><span class="line">    subscribeNext:^(NSNotification * _Nullable x) &#123;</span><br><span class="line">    //收到通知处理</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//KVO</span><br><span class="line">[RACObserve(self, name) subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    //值改变处理</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<br>

<h4 id="1、RACStream"><a href="#1、RACStream" class="headerlink" title="1、RACStream"></a>1、RACStream</h4><p>RACStream 是 ReactiveCocoa 中最核心的类，代表的是任意的值流，它是整个 RAC 得以建立的基础。<br>RACStream 是一个抽象类，通常情况下，我们并不会去实例化它，而是直接使用它的两个子类 RACSignal 和 RACSequence </p>
<p><img src="/images/2018/rac-3.png"></p>
<h6 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    // 3.发送信号</span><br><span class="line">    [subscriber sendNext:@&quot;message&quot;];</span><br><span class="line">    // 4.取消信号</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;取消订阅&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">// 2. 订阅信号</span><br><span class="line">RACDisposable *disposable = [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    //只要信号内部发出数据就会调用这个block</span><br><span class="line">    NSLog(@&quot;x --- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">// 取消订阅</span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure>

<p>RACSignal 有五个用来实现不同功能的私有子类：</p>
<ul>
<li>RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法；</li>
<li>RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法；</li>
<li>RACDynamicSignal ：动态信号，使用一个 block 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；</li>
<li>RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；</li>
<li>RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。</li>
</ul>
<p>RACSignal 的 subscribe 这个方法封装了订阅者对信号源的一次订阅过程，它是订阅者与信号源产生联系的唯一入口。</p>
<h6 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建信号</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">//订阅信号</span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block:处理数据</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">//发送信号</span><br><span class="line">[subject sendNext:@1];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RACSubject 继承自 RACSignal ，所以它可以作为信号源被订阅者订阅，同时，它又实现了 RACSubscriber 协议，所以它也可以作为订阅者订阅其他信号源，这个就是 RACSubject 为什么可以手动控制。</p>
<p>RACSubject 有三个用来实现不同功能的子类：</p>
<ul>
<li>RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能；</li>
<li>RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值；</li>
<li>RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。</li>
</ul>
<h6 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h6><p>RACSequence 代表的是一个不可变的值的序列。<br>一个 RACSequence 由两部分组成：</p>
<ul>
<li>head ：指的是序列中的第一个对象，如果序列为空，则为 nil ；</li>
<li>tail ：指的是序列中除第一个对象外的其它所有对象，同样的，如果序列为空，则为 nil</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSArray *strings = @[@&quot;1&quot;, @&quot;22&quot;, @&quot;333&quot;];</span><br><span class="line">RACSequence *results = [[strings.rac_sequence</span><br><span class="line">    filter:^ BOOL (NSString *str) &#123;</span><br><span class="line">        return str.length &gt;= 2;</span><br><span class="line">    &#125;] map:^(NSString *str) &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;--%@&quot;, results.array); //22  333</span><br></pre></td></tr></table></figure>
<p>可以非常方便地使用 RACSequence 来实现集合的链式操作，直到得到你想要的最终结果为止。</p>
<p>RACSequence 的一系列功能也是通过类簇来实现的：</p>
<ul>
<li>RACUnarySequence ：一元序列，用来实现 RACSequence 的 +return: 方法；</li>
<li>RACIndexSetSequence ：用来遍历索引集；</li>
<li>RACEmptySequence ：空序列，用来实现 RACSequence 的 +empty 方法；</li>
<li>RACDynamicSequence ：动态序列，使用 blocks 来动态地实现一个序列；</li>
<li>RACSignalSequence ：用来遍历信号中的值；</li>
<li>RACArraySequence ：用来遍历数组中的元素；</li>
<li>RACEagerSequence ：非懒计算的序列，在初始化时立即计算所有的值；</li>
<li>RACStringSequence ：用来遍历字符串中的字符；</li>
<li>RACTupleSequence ：用来遍历元组中的元素。</li>
</ul>
<br>

<h4 id="2、RACSubscriber"><a href="#2、RACSubscriber" class="headerlink" title="2、RACSubscriber"></a>2、RACSubscriber</h4><p>在 RAC 中，订阅者是一个抽象的概念，所有实现了 RACSubscriber 协议的类都可以作为信号源的订阅者。<br><img src="/images/2018/rac-4.png"></p>
<p>-sendNext: 、-sendError: 和 -sendCompleted 分别用来从 RACSignal 接收 next 、error 和 completed 事件，而 -didSubscribeWithDisposable: 则用来接收代表某次订阅的 disposable 对象。</p>
<p>订阅者对信号源的一次订阅过程可以抽象为：通过 RACSignal 的 -subscribe: 方法传入一个订阅者，并最终返回一个 RACDisposable 对象。</p>
<p>RACSubscriber 类的名字与 RACSubscriber 协议的名字相同，这跟 Objective-C 中的 NSObject 类的名字与 NSObject 协议的名字相同是一样的。通常来说，RACSubscriber 类充当的角色就是信号源的真正订阅者，实现了 RACSubscriber 协议。</p>
<br>

<h4 id="3、RACScheduler"><a href="#3、RACScheduler" class="headerlink" title="3、RACScheduler"></a>3、RACScheduler</h4><p>有了信号源和订阅者，我们还需要由调度器来统一调度订阅者订阅信号源的过程中所涉及到的任务，这样才能保证所有的任务都能够合理有序地执行。<br>RACScheduler 在 RAC 中就是扮演着调度器的角色，本质上，它就是用 GCD 的串行队列来实现的，并且支持取消操作。</p>
<p><img src="/images/2018/rac-5.png"></p>
<p>RACScheduler 的一系列功能也是通过类簇来实现的:</p>
<ul>
<li>RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器；</li>
<li>RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务；</li>
<li>RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务；</li>
<li>RACSubscriptionScheduler ：一个只用来调度订阅的调度器。</li>
</ul>
<br>

<h4 id="4、RACDisposable"><a href="#4、RACDisposable" class="headerlink" title="4、RACDisposable"></a>4、RACDisposable</h4><p>在订阅者订阅信号源的过程中，会产生副作用或者消耗一定的资源，所以当我们在取消订阅或者完成订阅时，我们就需要做一些资源回收和垃圾清理的工作。<br>RACDisposable 在 RAC 中就充当着清洁工的角色，它封装了取消和清理一次订阅所必需的工作。它有一个核心的方法 -dispose ，调用这个方法就会执行相应的清理工作。</p>
<p><img src="/images/2018/rac-6.png"></p>
<p>RACDisposable 总共有四个子类：</p>
<ul>
<li>RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来；</li>
<li>RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察；</li>
<li>RACCompoundDisposable ：跟 RACSerialDisposable 一样，RACCompoundDisposable 也是作为 disposable 的容器使用。不同的是，它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象，有点类似于可变数组 NSMutableArray 。而当一个 RACCompoundDisposable 对象被 disposed 时，它会调用其所包含的所有 disposable 对象的 -dispose 方法，有点类似于 autoreleasepool 的作用;</li>
<li>RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。</li>
</ul>
<h4 id="RAC-的使用"><a href="#RAC-的使用" class="headerlink" title="RAC 的使用"></a>RAC 的使用</h4><p>（以下代码例子来自：<a target="_blank" rel="noopener" href="https://github.com/shuaiwang007/RAC%EF%BC%89">https://github.com/shuaiwang007/RAC）</a></p>
<h6 id="RACSignal-1"><a href="#RACSignal-1" class="headerlink" title="RACSignal"></a>RACSignal</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    // 3.发送信号</span><br><span class="line">    [subscriber sendNext:@&quot;message&quot;];</span><br><span class="line">    // 4.取消信号，如果信号想要被取消，就必须返回一个RACDisposable</span><br><span class="line">    // 信号什么时候被取消：1.自动取消，当一个信号的订阅者被销毁的时候机会自动取消订阅，2.手动取消，</span><br><span class="line">    //block什么时候调用：一旦一个信号被取消订阅就会调用</span><br><span class="line">    //block作用：当信号被取消时用于清空一些资源</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;取消订阅&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">// 2. 订阅信号</span><br><span class="line">//subscribeNext, 把nextBlock保存到订阅者里面</span><br><span class="line">//只要订阅信号就会返回一个取消订阅信号的类</span><br><span class="line">RACDisposable *disposable = [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    //只要信号内部发出数据就会调用这个block</span><br><span class="line">    NSLog(@&quot;x --- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">// 取消订阅</span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure>
<br>

<h6 id="RACSubject-1"><a href="#RACSubject-1" class="headerlink" title="RACSubject"></a>RACSubject</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建信号</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">//订阅信号</span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // block:处理数据</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">//发送信号</span><br><span class="line">[subject sendNext:@1];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RACSubject必须要先订阅信号之后才能发送信号， 而RACReplaySubject可以先发送信号后订阅。</p>
<br>

<h6 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;发送请求&quot;);</span><br><span class="line">    // 发送信号</span><br><span class="line">    [subscriber sendNext:@&quot;message&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//每订阅一次信号就得重新创建并发送请求</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;1--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;2--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">//发送请求</span><br><span class="line">// 1--- message</span><br><span class="line">// 发送请求</span><br><span class="line">// 2--- message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用RACMulticastConnection，用一个信号内包装，不管有多少个订阅者，只发一次请求</span><br><span class="line">//创建连接类</span><br><span class="line">RACMulticastConnection *connection = [signal publish];</span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;1--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;2--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">//连接。只有连接了才会把信号源变为热信号</span><br><span class="line">[connection connect];</span><br><span class="line">//发送请求</span><br><span class="line">// 1--- message</span><br><span class="line">// 2--- message</span><br></pre></td></tr></table></figure>
<p>绑定信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">// 2.绑定信号</span><br><span class="line">RACSignal *bindSignal = [subject bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    </span><br><span class="line">    //只要绑定信号订阅就会调用 block</span><br><span class="line">    NSLog(@&quot;0--- &quot;);</span><br><span class="line">    </span><br><span class="line">    return ^RACSignal *(id value, BOOL *stop)&#123;</span><br><span class="line">        // 只要源信号发送数据，就会调用block</span><br><span class="line">        // value:源信号发送的内容 //value = @1; //可在这里修改发送信号的值</span><br><span class="line">        NSLog(@&quot;源信号的内容--- %@&quot;, value);</span><br><span class="line">        //返回信号，不能为nil,如果非要返回空,则empty或 alloc init</span><br><span class="line">        //把返回的值包装成信号</span><br><span class="line">        return [RACSignal return:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.订阅绑定信号</span><br><span class="line">[bindSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;绑定信号处理完的信号内容--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">// 4.发送信号</span><br><span class="line">[subject sendNext:@&quot;message&quot;];</span><br><span class="line">//0---</span><br><span class="line">//源信号的内容--- message</span><br><span class="line">//绑定信号处理完的信号内容--- message</span><br></pre></td></tr></table></figure>
<p>过滤信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 跳跃 ： 如下，skip传入2 跳过前面两个值</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject skip:2] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@1];</span><br><span class="line">[subject sendNext:@2];</span><br><span class="line">[subject sendNext:@3];</span><br><span class="line">//--- 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//distinctUntilChanged: 如果当前的值跟上一次的值一样，就不会被订阅到</span><br><span class="line">[[subject distinctUntilChanged] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// take:可以屏蔽一些值,去掉前面几个值---这里take为2 则只拿到前两个值</span><br><span class="line">[[subject take:2] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">//takeLast:和take的用法一样，不过他取的是最后的几个值，如下，则取的是最后两个值</span><br><span class="line">[[subject takeLast:2] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@1];</span><br><span class="line">[subject sendNext:@2];</span><br><span class="line">[subject sendNext:@3];</span><br><span class="line">[subject sendCompleted];</span><br><span class="line">//--- 2</span><br><span class="line">//--- 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// takeUntil:---给takeUntil传的是哪个信号，</span><br><span class="line">//那么当这个信号发送信号或sendCompleted，就不能再接受源信号的内容了。</span><br><span class="line">[[subject takeUntil:subject2] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ignore:忽略一些值. ignoreValues:表示忽略所有的值</span><br><span class="line">RACSignal *ignoreSignal = [subject ignore:@2]; //忽略值 @2</span><br><span class="line">[ignoreSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 一般和文本框一起用，添加过滤条件</span><br><span class="line">// 只有当文本框的内容长度大于5，才获取文本框里的内容</span><br><span class="line">[[self.textField.rac_textSignal filter:^BOOL(id value) &#123;</span><br><span class="line">    // value 源信号的内容</span><br><span class="line">    return [value length] &gt; 5;</span><br><span class="line">    // 返回值 就是过滤条件。只有满足这个条件才能获取到内容</span><br><span class="line">&#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>映射<br>想要拦截服务器返回的数据，给数据拼接特定的东西或想对数据进行操作从而更改返回值，类似于这样的情况下，可以考虑用RAC的映射</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 创建信号</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">// 绑定信号</span><br><span class="line">RACSignal *bindSignal = [subject map:^id _Nullable(id  _Nullable value) &#123;</span><br><span class="line">    // 返回的类型就是你需要映射的值.</span><br><span class="line">    return [NSString stringWithFormat:@&quot;--- %@&quot;, value];</span><br><span class="line">&#125;];</span><br><span class="line">// 订阅绑定信号</span><br><span class="line">[bindSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">// 发送信号</span><br><span class="line">[subject sendNext:@&quot;message&quot;];</span><br><span class="line">//--- message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// flattenMap中返回的是什么信号，订阅的就是什么信号</span><br><span class="line">RACSignal *bindSignal = [subject flattenMap:^__kindof RACSignal * _Nullable(id  _Nullable value) &#123;</span><br><span class="line">    // value: 就是源信号发送的内容. 返回信号用来包装成修改内容的值</span><br><span class="line">    return [RACSignal return:value];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// flattenMap 主要用于信号中的信号</span><br><span class="line">// 创建信号</span><br><span class="line">RACSubject *signalofSignals = [RACSubject subject];</span><br><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line">// 订阅信号</span><br><span class="line">[[signalofSignals flattenMap:^__kindof RACSignal * _Nullable(id  _Nullable value) &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">// 发送信号</span><br><span class="line">[signalofSignals sendNext:signal];</span><br><span class="line">[signal sendNext:@&quot;123&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>组合信号<br>把多个信号聚合成想要的信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *combinSignal = [RACSignal combineLatest:@[self.accountField.rac_textSignal, self.pwdField.rac_textSignal] reduce:^id(NSString *account, NSString *pwd)&#123; //reduce里的参数一定要和combineLatest数组里的一一对应。</span><br><span class="line">    // block: 只要源信号发送内容，就会调用，组合成一个新值。</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;, account, pwd);</span><br><span class="line">    return @(account.length &amp;&amp; pwd.length);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 订阅信号</span><br><span class="line">[combinSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    self.loginBtn.enabled = [x boolValue];</span><br><span class="line">&#125;];</span><br><span class="line">// 可以直接用RAC宏</span><br><span class="line">//RAC(self.loginBtn, enabled) = combinSignal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//zipWith:把两个信号压缩成一个信号, 只有当两个信号同时发出信号内容时, 才会触发压缩流的next事件。</span><br><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line">RACSubject *signalB = [RACSubject subject];</span><br><span class="line">// 压缩成一个信号</span><br><span class="line">RACSignal *zipSignal = [signalA zipWith:signalB];</span><br><span class="line">// 等所有信号都发送内容的时候才会调用</span><br><span class="line">[zipSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x); //所有的值都被包装成了元组</span><br><span class="line">&#125;];</span><br><span class="line">//发送信号 元组内元素的顺序,跟发送的顺序无关，</span><br><span class="line">//而是跟压缩的顺序有关[signalA zipWith:signalB],先是A后是B</span><br><span class="line">[signalB sendNext:@2];</span><br><span class="line">[signalA sendNext:@1];</span><br><span class="line">//--- &lt;RACTwoTuple&gt; (1, 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// merge:多个信号合并成一个信号，任何一个信号发送信息都会调用</span><br><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line">RACSubject *signalB = [RACSubject subject];</span><br><span class="line">//组合信号</span><br><span class="line">RACSignal *mergeSignal = [signalA merge:signalB];</span><br><span class="line">// 订阅信号</span><br><span class="line">[mergeSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">//发送信号</span><br><span class="line">[signalA sendNext:@&quot;message1&quot;];</span><br><span class="line">[signalB sendNext:@&quot;message2&quot;];</span><br><span class="line">//--- message1</span><br><span class="line">//--- message2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// then. 有两部分数据：想先获取上部分数据，然后进行下部分的，拿到下部分数据</span><br><span class="line">// 创建信号A</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;A---&quot;);</span><br><span class="line">    [subscriber sendNext:@&quot;messageA&quot;];</span><br><span class="line">    [subscriber sendCompleted]; // 上部分信号发送完，必须要调用sendCompleted方法</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">// 创建信号B，</span><br><span class="line">RACSignal *signalsB = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;B---&quot;);</span><br><span class="line">    [subscriber sendNext:@&quot;messageB&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">// 创建组合信号</span><br><span class="line">// then;忽略掉第一个信号的所有值</span><br><span class="line">RACSignal *thenSignal = [signalA then:^RACSignal * _Nonnull&#123;</span><br><span class="line">    // 返回的信号就是要组合的信号</span><br><span class="line">    return signalsB;</span><br><span class="line">&#125;];</span><br><span class="line">// 订阅信号</span><br><span class="line">[thenSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">//A---</span><br><span class="line">//B---</span><br><span class="line">//--- messageB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// concat. 有两部分数据：想让上部分先执行，完了之后再让下部分执行（都可获取值）</span><br><span class="line">// 创建信号A</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;A---&quot;);</span><br><span class="line">    [subscriber sendNext:@&quot;messageA&quot;];</span><br><span class="line">    [subscriber sendCompleted]; // 上部分信号发送完必须要调用sendCompleted方法</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">// 创建信号B</span><br><span class="line">RACSignal *signalsB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;B---&quot;);</span><br><span class="line">    [subscriber sendNext:@&quot;messageB&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">// concat:按顺序去链接</span><br><span class="line">// 创建组合信号</span><br><span class="line">RACSignal *concatSignal = [signalA concat:signalsB];</span><br><span class="line">// 订阅组合信号</span><br><span class="line">[concatSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">//A---</span><br><span class="line">//--- messageA</span><br><span class="line">//B---</span><br><span class="line">//--- messageB</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<h6 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h6><p>RACCommand 用于处理事件的类，可以把事件如何处理，事件中的数据如何传递，包装到这个类中，可以很方便的监控事件的执行过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建命令</span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) &#123;</span><br><span class="line">    //执行命令的时候就会调用block. input传进来的参数</span><br><span class="line">    NSLog(@&quot;0--- %@&quot;, input);</span><br><span class="line">    //返回值不允许为nil</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;message&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 订阅命令内部的信号. 直接订阅执行命令返回的信号</span><br><span class="line">// 2.执行命令</span><br><span class="line">RACSignal *signal =[command execute:@1];</span><br><span class="line">// 订阅信号</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;1--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">//0--- 1</span><br><span class="line">//1--- message</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 方式二：</span><br><span class="line">// 订阅信号, 先订阅才能发送命令</span><br><span class="line">// command.executionSignals：信号源，信号中信号，signalofsignals:信号，发送数据就是信号</span><br><span class="line">// command.executionSignals.switchToLatest获取最新发送的信号，只能用于信号中信号。</span><br><span class="line">[command.executionSignals subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    [x subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;2--- %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//执行命令</span><br><span class="line">[command execute:@2];</span><br><span class="line">//0--- 2</span><br><span class="line">//2--- message</span><br></pre></td></tr></table></figure>
<p>信号中的信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// switchToLatest--用于信号中信号</span><br><span class="line">// 创建信号中信号</span><br><span class="line">RACSubject *signalofsignals = [RACSubject subject];</span><br><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[signalofsignals subscribeNext:^(RACSubject *x) &#123;</span><br><span class="line">    [x subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;1--- %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// switchToLatest: 获取信号中信号发送的最新信号</span><br><span class="line">[signalofsignals.switchToLatest subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;2--- %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 发送信号</span><br><span class="line">[signalofsignals sendNext:signalA];</span><br><span class="line">[signalA sendNext:@4];</span><br></pre></td></tr></table></figure>
<p>监听事件有没有完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 监听事件有没有完成</span><br><span class="line">// 1.创建命令</span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) &#123;</span><br><span class="line">    //执行命令的时候就会调用block. input传进来的参数</span><br><span class="line">    NSLog(@&quot;0--- %@&quot;, input);</span><br><span class="line">    //返回值不允许为nil</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        //发送数据</span><br><span class="line">        [subscriber sendNext:@&quot;message&quot;];</span><br><span class="line">        </span><br><span class="line">        //发送完成, 当前命令内部发送数据完成，一定要主动发送完成</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 监听事件有没有完成</span><br><span class="line">[command.executing subscribeNext:^(NSNumber * _Nullable x) &#123;</span><br><span class="line">    if ([x boolValue] == YES) &#123;</span><br><span class="line">        // 正在执行</span><br><span class="line">        NSLog(@&quot;1--- 正在执行 %@&quot;, x);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 执行完成/没有执行</span><br><span class="line">        NSLog(@&quot;2--- 执行完成/没有执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.执行命令</span><br><span class="line">[command execute:@1];</span><br></pre></td></tr></table></figure>

<br>

<h6 id="RACSequence-1"><a href="#RACSequence-1" class="headerlink" title="RACSequence"></a>RACSequence</h6><p>可以快速高效的遍历数组和字典：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;11&quot;, @&quot;age&quot;:@&quot;22&quot;&#125;;</span><br><span class="line"></span><br><span class="line">[dict.rac_sequence.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    RACTupleUnpack(NSString *key, NSString *value) = x;</span><br><span class="line">    NSLog(@&quot;--- %@ %@&quot;, key, value);</span><br><span class="line">&#125; error:^(NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;, error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    NSLog(@&quot;--- completed&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">// --- name 11</span><br><span class="line">// --- age 22</span><br><span class="line">// --- completed</span><br></pre></td></tr></table></figure>

<h6 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  KVO</span><br><span class="line"> *  RACObserveL:快速的监听某个对象的某个属性改变</span><br><span class="line"> *  返回的是一个信号,对象的某个属性改变的信号</span><br><span class="line"> */</span><br><span class="line">[RACObserve(self.view, center) subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//例 textField输入的值赋值给label，监听label文字改变,</span><br><span class="line">RAC(self.label, text) = self.textField.rac_textSignal;</span><br><span class="line">[RACObserve(self.label, text) subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;--- label的文字变了&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  循环引用问题</span><br><span class="line"> *  使用 @weakify(self)和@strongify(self)来避免循环引用</span><br><span class="line"> */</span><br><span class="line">@weakify(self)</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    NSLog(@&quot;%@&quot;,self.view);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 快速包装一个元组</span><br><span class="line"> * 把包装的类型放在宏的参数里面,就会自动包装</span><br><span class="line"> */</span><br><span class="line">RACTuple *tuple = RACTuplePack(@1, @2, @4);</span><br><span class="line">// 宏的参数类型要和元祖中元素类型一致， 右边为要解析的元祖。</span><br><span class="line">RACTupleUnpack_(NSNumber *num1, NSNumber *num2, NSNumber * num3) = tuple;// 4.元祖</span><br><span class="line">// 快速包装一个元组</span><br><span class="line">// 把包装的类型放在宏的参数里面,就会自动包装</span><br><span class="line">NSLog(@&quot;%@ %@ %@&quot;, num1, num2, num3);</span><br><span class="line">//1 2 4</span><br></pre></td></tr></table></figure>

<p>有关 RAC 在 MVVM 架构中的使用，可以参考小例子：<br>GitHub:  <strong><a target="_blank" rel="noopener" href="https://github.com/MA806P/MV-X_Project">MV-X_Project</a></strong></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/">http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/</a><br><a target="_blank" rel="noopener" href="http://learnyouahaskell.com/chapters">http://learnyouahaskell.com/chapters</a><br><a target="_blank" rel="noopener" href="http://williamzang.com/blog/2016/06/27/ios-kai-fa-xia-de-han-shu-xiang-ying-shi-bian-cheng/">http://williamzang.com/blog/2016/06/27/ios-kai-fa-xia-de-han-shu-xiang-ying-shi-bian-cheng/</a></p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>