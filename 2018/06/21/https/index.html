<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    HTTPS 丨
    

    Peng&#39;s blog
  </title>

  
  <link rel="shortcut icon" href="/images/favicon.ico">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Peng&#39;s blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">HTTPS</div>
  <div class="post-meta">
    <div class="date">2018 June 21st</div>
    <div class="tags">
      
      <div class="tag-item">网络</div>
      
    </div>
  </div>
  

  <main class="post-content"><p>在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。本篇文章来了解一下 HTTPS。</p>
<h4 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h4><h5 id="1、通信使用明文，不加密，内容可能会被窃听"><a href="#1、通信使用明文，不加密，内容可能会被窃听" class="headerlink" title="1、通信使用明文，不加密，内容可能会被窃听"></a>1、通信使用明文，不加密，内容可能会被窃听</h5><p>由于 HTTP 本身不具备加密的功能，无法做到对 HTTP 协议通信的请求和响应的内容进行加密。<br>TCP&#x2F;IP 是可能被窃听的网络，TCP&#x2F;IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。<br>即使已经过加密处理的通信，也会被窥视到通信内容，只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。</p>
<h5 id="2、不验证通信方的身份，因此有可能遭遇伪装"><a href="#2、不验证通信方的身份，因此有可能遭遇伪装" class="headerlink" title="2、不验证通信方的身份，因此有可能遭遇伪装"></a>2、不验证通信方的身份，因此有可能遭遇伪装</h5><p>HTTP 协议中的请求和响应不会对通信方进行确认，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应，但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下。</p>
<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。</li>
</ul>
<h5 id="3、无法证明报文的完整性，有可能已遭篡改"><a href="#3、无法证明报文的完整性，有可能已遭篡改" class="headerlink" title="3、无法证明报文的完整性，有可能已遭篡改"></a>3、无法证明报文的完整性，有可能已遭篡改</h5><p>由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br>换句话说，没有任何办法确认，发出的请求 &#x2F; 响应和接收到的请求 &#x2F; 响应是前后相同的。<br>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><blockquote>
<p>HTTP+ 加密 + 认证 + 完整性保护 &#x3D; HTTPS</p>
</blockquote>
<p>对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。<br>为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。</p>
<p>使用 HTTPS 通信时，不再用 http:&#x2F;&#x2F;，而是改用 https:&#x2F;&#x2F;。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。</p>
<p><img src="/images/2018/https-1.png"></p>
<br>

<h5 id="1、HTTPS-是身披-SSL-外壳的-HTTP"><a href="#1、HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="1、HTTPS 是身披 SSL 外壳的 HTTP"></a>1、HTTPS 是身披 SSL 外壳的 HTTP</h5><p>HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全传输层协议）的组合使用，加密 HTTP 的通信内容。<br>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p>
<p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p>
<p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<br>

<h5 id="2、相互交换密钥的公开密钥加密技术"><a href="#2、相互交换密钥的公开密钥加密技术" class="headerlink" title="2、相互交换密钥的公开密钥加密技术"></a>2、相互交换密钥的公开密钥加密技术</h5><p>SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。<br>加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p>
<ul>
<li><p>共享密钥加密的困境<br>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。<br>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
</li>
<li><p>公开密钥加密<br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。<br>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。</p>
</li>
<li><p>HTTPS 采用混合加密机制<br>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。<br>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
</li>
</ul>
<br>

<h5 id="3、证明公开密钥正确性的证书"><a href="#3、证明公开密钥正确性的证书" class="headerlink" title="3、证明公开密钥正确性的证书"></a>3、证明公开密钥正确性的证书</h5><p>公开密钥加密方式还是存在一些问题的。如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。<br>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。<br>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。<br>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。</p>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>
<p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certificate）。</p>
<br>

<h5 id="4、HTTPS-的安全通信机制"><a href="#4、HTTPS-的安全通信机制" class="headerlink" title="4、HTTPS 的安全通信机制"></a>4、HTTPS 的安全通信机制</h5><p><img src="/images/2018/https-2.png" alt="HTTPS 通信"></p>
<p>1&gt; 客户端发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>
<p>2&gt; 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>
<p>3&gt; 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
<p>4&gt; 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p>
<p>5&gt; SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用公开密钥进行加密。</p>
<p>6&gt; 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>
<p>7&gt; 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>
<p>8&gt; 服务器同样发送 Change Cipher Spec 报文。</p>
<p>9&gt; 服务器同样发送 Finished 报文。</p>
<p>10&gt; 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p>
<p>11&gt; 应用层协议通信，即发送 HTTP 响应。</p>
<p>12&gt; 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p>
<p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。<br>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。<br>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。<br>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。<br>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。</p>
<br>

<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>本文有关内容来自： <a target="_blank" rel="noopener" href="https://book.douban.com/subject/25863515/">《图解HTTP》</a> </p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>