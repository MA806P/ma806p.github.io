<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    GCD 多线程 小结 丨
    

    Peng&#39;s blog
  </title>

  
  <link rel="shortcut icon" href="/images/favicon.ico">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Peng&#39;s blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">GCD 多线程 小结</div>
  <div class="post-meta">
    <div class="date">2019 October 30th</div>
    <div class="tags">
      
      <div class="tag-item">基础</div>
      
      <div class="tag-item">OC</div>
      
    </div>
  </div>
  

  <main class="post-content"><p>本文是对 iOS 中 GCD (Grand Central Dispatch) 的整理小结。总结了有关线程的知识点、GCD 的对应的使用方法。  </p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>线程是系统能够进行运算调度的最小单位，线程被包含在进程中，是进程中的实际运作单位。一个程序至少有一个进程，一个进程至少有一个线程。一个进程中可以并发多个线程，执行不同的任务，可充分利用系统资源，提高性能。  </p>
<p>进程是系统进行资源分配和调度的一个独立单位。线程自己基本上不拥有系统资源，同一个进程中的多个线程共享进程所拥有的资源。当多个线程对同一个资源进行操作的时候需要注意线程安全问题。  </p>
<p>iOS 中的程序启动，创建好一个进程的同时， 一个线程便开始运行，这个线程叫主线程。有关界面的显示操作，即 UIKit 的操作在主线程进行。 有关多线程的操作，主要依靠 GCD 和 NSOperation。  </p>
<p><strong>相关概念</strong>  </p>
<ul>
<li><p>串行（Serial）：在固定时间内只能执行单个任务。  </p>
</li>
<li><p>并行（Parallel）：在固定时间内同时执行多个任务。  </p>
</li>
<li><p>并发（Concurrent）：在固定时间内可以执行多个任务。它和并行（Parallel）的区别在于，并发不会同时执行多个任务，而是通过在任务间不断切换去完成多个任务，多个任务在同一时间间隔内执行。  </p>
</li>
<li><p>同步（Sync）：会把当前的任务加入到队列中，除非该任务执行完成，线程才会返回继续运行，也就是说同步会阻塞线程。任务在执行和结束一定遵循先后顺序，即先执行的任务一定先结束。  </p>
</li>
<li><p>异步（Async）：会把当前的任务加入到队列中，但它会立刻返回，无需等任务执行完成，也就是说异步不会阻塞线程。任务在执行和结束不遵循先后顺序。可能先执行的任务先结束，也可能后执行的任务先结束。</p>
</li>
</ul>
<p>串行是同步的执行方式。<br>并发和并行是异步执行的两种执行方式。  </p>
<br>

<h3 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h3><p>GCD (Grand Central Dispatch) 是一个异步执行的技术，将应用程序中线程管理的代码在系统层级中实现，开发者只要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程执行任务，就是用非常简洁的方法，实现了复杂繁琐的多线程编程。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      //执行任务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 Block 语法定义要执行的任务，通过 dispatch_async 函数将任务追加到 queue 队列中，这样就可以使指定的 Block 在另一线程中执行。  </p>
<h4 id="1、Dispatch-Queue"><a href="#1、Dispatch-Queue" class="headerlink" title="1、Dispatch Queue"></a>1、Dispatch Queue</h4><p>两种队列：串行队列 Serial Dispatch Queue；并发队列 Concurrent Dispatch Queue。  </p>
<h5 id="1-1-创建队列的方法："><a href="#1-1-创建队列的方法：" class="headerlink" title="1.1 创建队列的方法："></a>1.1 创建队列的方法：</h5><p>1、dispatch_queue_create 函数  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列 DISPATCH_QUEUE_SERIAL，可写成 NULL</span><br><span class="line">// 并发队列 DISPATCH_QUEUE_CONCURRENT</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数指定队列的名称，方便调试。</li>
<li>第二个参数 Serial Dispatch Queue 指定为 NULL，Concurrent Dispatch Queue 指定为 DISPATCH_QUEUE_CONCURRENT。</li>
<li>返回值为 Dispatch Queue，dispatch_queue_t 类型</li>
</ul>
<p>2、获取系统标准提供的 Dispatch Queue<br>不用特意创建生成 Dispatch Queue 系统也会给我们提供几个，Main Dispatch Queue 和 Global Dispatch Queue  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<ul>
<li>Main Dispatch Queue 是在主线程执行的队列 ，主线程只有1个，所以 Main Dispatch Queue 是串行队列 Serial Dispatch Queue。有关用户界面更新等一些必须在主线程中执行的处理，需要追加到 Main Dispatch Queue 中处理。这与 performSelectorOnMainThread 执行方法相同。  </li>
<li>Global Dispatch Queue 是所有应用程序都能使用的 Concurrent Dispatch Queue，没有必要通过 dispatch_queue_create 生成，只要获取 Global Dispatch Queue 使用即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Global Dispatch Queue 有4个执行优先级，向队列中追加处理时，应选择与处理内容对应的优先级。</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2      //高优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0   //默认优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)    //低优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN  //后台优先级</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>

<h5 id="1-2-串行队列"><a href="#1-2-串行队列" class="headerlink" title="1.2 串行队列"></a>1.2 串行队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">//end</span><br><span class="line">//1 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>串行队列，要等待当前任务处理结束，1执行结束，接着执行2，如此重复，同时执行的处理数只能有一个，顺序执行任务。<br>一旦生成 Serial Dispatch Queue 并追加处理，系统对于一个 Serial Dispatch Queue 就只生成并使用一个线程。<br>在一个 Serial Dispatch Queue 中只能执行一个追加处理，但如果生成多个 Serial Dispatch Queue 将并发执行，各个执行一个处理，即为同时执行多个处理。<br><br></p>
<h5 id="1-3-并发队列"><a href="#1-3-并发队列" class="headerlink" title="1.3 并发队列"></a>1.3 并发队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">//end</span><br><span class="line">//2 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">//1 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>并发队列，使用多个线程同时执行多个处理，不用等待当前任务处理结束，就开始执行后面的任务，可并发执行多个任务，得到的结果打印顺序，不会按照代码追加到队列的顺序，是打乱的。<br><br></p>
<h4 id="2、dispatch-sync-同步操作函数、dispatch-async-异步操作函数"><a href="#2、dispatch-sync-同步操作函数、dispatch-async-异步操作函数" class="headerlink" title="2、dispatch_sync 同步操作函数、dispatch_async 异步操作函数"></a>2、dispatch_sync 同步操作函数、dispatch_async 异步操作函数</h4><ul>
<li><p>dispatch_sync 函数，将指定的 block 同步地追加到指定的 Dispatch Queue 中，在追加 block 任务结束之前，dispatch_sync 函数会一直等待。  </p>
</li>
<li><p>dispatch_async 函数，将指定的 block 任务异步地追加到指定的 Dispatch Queue 中，dispatch_async 函数不做任何等待。</p>
</li>
</ul>
<h5 id="2-1-在串行队列上进行同步-异步操作"><a href="#2-1-在串行队列上进行同步-异步操作" class="headerlink" title="2.1 在串行队列上进行同步&#x2F;异步操作"></a>2.1 在串行队列上进行同步&#x2F;异步操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;11 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;22 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;33 --- &quot;);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//11 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//22 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//33 ---    </span><br></pre></td></tr></table></figure>
<p>在串行队列上进行同步操作，所有任务将顺序执行。不会开启线程，在主线程上顺序执行任务，相当于直接执行任务的代码。<br><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;a --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;--- %d&quot;, sum);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;aa --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;b --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;bb --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;c --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;cc ---&quot;);</span><br><span class="line"></span><br><span class="line">//aa --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//a --- &lt;NSThread: 0x6000026d3000&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//bb --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//cc ---</span><br><span class="line">//--- 100000</span><br><span class="line">//b --- &lt;NSThread: 0x6000026d3000&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//c --- &lt;NSThread: 0x6000026d3000&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在串行队列上进行异步操作，如上代码，打印顺序不固定，但是 aa – bb – cc 一定是按照这个顺序打印的。a – b – c – 一定是按照这个顺序处理队列的任务的，异步执行另开一个线程，执行串行队列里的任务，一次只能执行一个任务，a 执行完，再执行 b，以此类推。<br><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial3&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//4 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600001086880&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在串行队列上进行，同步、异步嵌套。串行队列一次只能执行一个任务，同步执行的函数要等待 block 任务执行完成后，再去执行嵌套的串行队列上的 block 任务，所以打印的顺序为 1 – 2– 4 – 3，5的顺序不固定，可能在 3 前，可能在 3 后。一定是 1 – 2 – 4 先执行完，然后串行队列才能让 3 执行，一个任务执行完，才能执行下一个任务。<br><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial5&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x600001ea6280&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x600001efc6c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x600001ea6280&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//崩溃，死锁</span><br></pre></td></tr></table></figure>
<p>在串行队列上进行，异步、同步嵌套。如上代码，会产生死锁。<br>先异步执行 block 的任务，任务里面嵌套的，同步执行的任务也在串行队列中，需要等待要同步执行的任务完成才能返回，但是串行异步执行的任务已经在进行了，因为串行队列一次只能执行一个任务，同步执行的任务也需要等待，这就造成了两者相互等待，死锁。  </p>
<p>同样的在串行队列上，同步嵌套，也会产生死锁。这就是我们常常遇到的主线程死锁问题。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial5&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">      //...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//上面的代码，在第二个 dispatch_sync 执行时就会发生死锁</span><br><span class="line">//当前串行队列有任务正在执行，相互等待，死锁</span><br><span class="line"></span><br><span class="line">//在项目中经常遇到，切换到主线程执行的情况这时需要注意了</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    		//主线程死锁</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三方库 SDWebImage 提供一种解决方法 dispatch_main_async_safe(block)</span><br><span class="line">if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   dispatch_async(dispatch_get_main_queue(), block);</span><br><span class="line">&#125;</span><br><span class="line">//先判断当前任是否在主队列上，如果是直接执行任务就行了，不用切换到主队列上</span><br><span class="line">//否则的话用异步调用主队列，执行任务。这样可避免主线程死锁</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>谨慎使用同步操作。其实在主线程队列中使用同步操作是一定会构成死锁的，所以建议在串行队列中不要使用同步操作。<br><br></p>
<h5 id="2-2-在并发队列上进行同步-异步操作"><a href="#2-2-在并发队列上进行同步-异步操作" class="headerlink" title="2.2 在并发队列上进行同步&#x2F;异步操作"></a>2.2 在并发队列上进行同步&#x2F;异步操作</h5><p>与上面串行队列操作类似：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;11 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;22 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;33 --- &quot;);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//11 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//22 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//33 ---</span><br></pre></td></tr></table></figure>
<p>在并发队列上进行同步操作，所有任务顺序执行。<br><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;a --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;a --- %d %@&quot;, sum,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;aa --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;b --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;b --- %d %@&quot;, sum,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;bb --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;c --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;c --- %d %@&quot;, sum,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;cc ---&quot;);</span><br><span class="line"></span><br><span class="line">//aa --- &lt;NSThread: 0x600003a1e380&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//a --- &lt;NSThread: 0x600003a7c440&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">//bb --- &lt;NSThread: 0x600003a1e380&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//b --- &lt;NSThread: 0x600003a16ac0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">//cc ---</span><br><span class="line">//c --- &lt;NSThread: 0x600003a85240&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">//a --- 100000 &lt;NSThread: 0x600003a7c440&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">//b --- 100000 &lt;NSThread: 0x600003a16ac0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">//c --- 100000 &lt;NSThread: 0x600003a85240&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在并发队列上进行异步操作，另开线程各自执行，如上打印情况，只能确定 aa – bb – cc 这样的执行顺序，block 内的打印顺序不确定，<br><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">                sum += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;3 --- %d %@&quot;, sum, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//4 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000003d6a80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- 100000 &lt;NSThread: 0x6000003d6a80&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在并发队列中进行同步、异步嵌套，不会构成死锁。<br><br></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x6000003dc580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000003dc580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//4 --- &lt;NSThread: 0x6000003dc580&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在并发队列中进行异步、同步步嵌套，并发队列，可多任务并发处理，不会构成死锁。<br><br></p>
<h4 id="3、dispatch-barrier-async、dispatch-barrier-sync"><a href="#3、dispatch-barrier-async、dispatch-barrier-sync" class="headerlink" title="3、dispatch_barrier_async、dispatch_barrier_sync"></a>3、dispatch_barrier_async、dispatch_barrier_sync</h4><p>栅栏函数，像一个分界线，将同一个队列中的任务分开。分隔开的任务，前半部分任务执行完，栅栏函数执行，栅栏函数执行完，后半部分再执行。<br>类似的同步 sync、异步 async，同步函数等待任务执行完才返回，异步函数立即返回，无需等待任务完成。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        dispatch_queue_t queue = dispatch_queue_create(&quot;my.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --1 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --2 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        //等待栅栏函数执行完，再执行后面的任务</span><br><span class="line">        dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;%@ -- 分隔线 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --3 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --4 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;-- end&quot;);</span><br><span class="line">        </span><br><span class="line">// -- end</span><br><span class="line">// &lt;NSThread: 0x6000024d4280&gt;&#123;number = 4, name = (null)&#125; --1</span><br><span class="line">// &lt;NSThread: 0x6000024a7bc0&gt;&#123;number = 6, name = (null)&#125; --2</span><br><span class="line">// &lt;NSThread: 0x6000024a7bc0&gt;&#123;number = 6, name = (null)&#125; -- 分隔线 </span><br><span class="line">// &lt;NSThread: 0x6000024a7bc0&gt;&#123;number = 6, name = (null)&#125; --3</span><br><span class="line">// &lt;NSThread: 0x6000024d4280&gt;&#123;number = 4, name = (null)&#125; --4</span><br></pre></td></tr></table></figure>
<p>注意，上面使用的自定义的队列 dispatch_queue_create()，如果使用 dispatch_get_global_queue() 队列则栅栏没有分割效果。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//如果将上面的代码，栅栏函数换成 dispatch_barrier_sync 同步的，打印内容如下</span><br><span class="line">//注意 end 打印位置，主线程被阻塞，等待 dispatch_barrier_sync 任务执行完成返回，然后才继续下面的任务</span><br><span class="line"></span><br><span class="line">// &lt;NSThread: 0x6000010cb480&gt;&#123;number = 4, name = (null)&#125; --2</span><br><span class="line">// &lt;NSThread: 0x6000010ed540&gt;&#123;number = 6, name = (null)&#125; --1</span><br><span class="line">// &lt;NSThread: 0x600001088f00&gt;&#123;number = 1, name = main&#125; -- 分隔线 </span><br><span class="line">// -- end</span><br><span class="line">// &lt;NSThread: 0x6000010ed540&gt;&#123;number = 6, name = (null)&#125; --3</span><br><span class="line">// &lt;NSThread: 0x6000010cb480&gt;&#123;number = 4, name = (null)&#125; --4</span><br></pre></td></tr></table></figure>

<br>

<h4 id="4、dispatch-after"><a href="#4、dispatch-after" class="headerlink" title="4、dispatch_after"></a>4、dispatch_after</h4><p>在指定时间后处理任务，可以使用 dispatch_after 函数来实现  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), </span><br><span class="line">               dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;done ---&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>dispatch_after 函数不是在指定时间后执行处理，而是在指定时间追加处理到 Dispatch Queue 中。上面例子，与在3秒后用 dispatch_async 函数追加 block 任务到 Main Dispatch Queue 的操作相同。<br>Main Dispatch Queue 在主线程的 RunLoop 中执行，在如每隔 1&#x2F;60 秒执行的 RunLoop 中，block 最快在 3 秒后执行，最慢在 3秒+1&#x2F;60秒后执行，如在 Main Dispatch Queue 有大量追加任务或主线程处理本身有延迟，这个时间会更长。  </p>
<br>

<h4 id="5、Dispatch-Group"><a href="#5、Dispatch-Group" class="headerlink" title="5、Dispatch Group"></a>5、Dispatch Group</h4><p>在多线程中想监控，追加到队列中的任务都全部完成后，然后再进行处理，这种情况可以使用 Dispatch Group。例如处理完页面所有数据后，最后再在主线程上刷新页面。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;done --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line"></span><br><span class="line">//2 --- &lt;NSThread: 0x600001969c80&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000019fd800&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">//1 --- &lt;NSThread: 0x600001983500&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">//done --- &lt;NSThread: 0x600000fae280&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_group_wait 函数，在指定的时间内，等待追加到 group 的 队列中的任务是否执行完毕。<br>dispatch_group_wait 是一个同步操作，会阻塞线程。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);</span><br><span class="line">long result = dispatch_group_wait(group, time);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">    //追加到 group 的 队列中的任务全部执行完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="6、dispatch-apply"><a href="#6、dispatch-apply" class="headerlink" title="6、dispatch_apply"></a>6、dispatch_apply</h4><p>dispatch_apply 函数按指定的次数将指定的 block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;];</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_apply(array.count, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;--- %@ %@&quot;, array[index], [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;--- done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/images/2019/gcd-1.png">  </p>
<br>

<h4 id="7、Dispatch-Semaphore"><a href="#7、Dispatch-Semaphore" class="headerlink" title="7、Dispatch Semaphore"></a>7、Dispatch Semaphore</h4><p>Dispatch Semaphore 是持有计数的信号。  </p>
<ul>
<li>dispatch_semaphore_create 函数可以生成信号量，参数是信号量计数的初始值。  </li>
<li>dispatch_semaphore_wait 函数，当信号量值为 0 时等待，等待直到超时，参数可设置超时时长。信号量值大于等于 1 时，不等待，同时将信号量值减 1。  </li>
<li>dispatch_semaphore_signal 函数会让信号量值加 1，如果有通过dispatch_semaphore_wait 函数等待信号量值增加的线程，会由系统唤醒最先等待的线程执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p>在 iOS 开发时，经常遇到一个页面有多个网络数据请求的场景，等多个网络请求获取到数据后再去刷新页面，那么这是就可以使用 Dispatch Semaphore 可与 Dispatch Group<br>来实现这一功能，代码如下，两个链接分别加载两张图片，当两个图片都下载完成后，在一起显示在界面上：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *images = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    dispatch_semaphore_t semaphore1 = dispatch_semaphore_create(1);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        //开始下载第一张图片</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&quot;https://xxxx.png&quot;]];</span><br><span class="line">        NSString *path=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)    objectAtIndex:0];</span><br><span class="line">        NSString *filename=[path stringByAppendingPathComponent:@&quot;banner1.png&quot;];</span><br><span class="line">        //在该路径下创建图片文件，并将存储图片的数据存到本地</span><br><span class="line">        NSFileManager* fm = [NSFileManager defaultManager];</span><br><span class="line">        [fm createFileAtPath:filename contents:imageData attributes:nil];</span><br><span class="line">        </span><br><span class="line">        [images addObject:filename];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore1);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_semaphore_wait(semaphore1, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    dispatch_semaphore_t semaphore2 = dispatch_semaphore_create(0);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        //开始下载第二张图片</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&quot;https://xxxx.png&quot;]];</span><br><span class="line">        NSString *path=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)  objectAtIndex:0];</span><br><span class="line">        NSString *filename=[path stringByAppendingPathComponent:@&quot;banner2.png&quot;];</span><br><span class="line">        NSFileManager* fm = [NSFileManager defaultManager];</span><br><span class="line">        [fm createFileAtPath:filename contents:imageData attributes:nil];</span><br><span class="line">        [images addObject:filename];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //初始化信号量计数为0，会一直等待下载图片</span><br><span class="line">    //上面的异步下载图片完成后会调用 dispatch_semaphore_signal 函数</span><br><span class="line">    // 然后信号量计数加 1，这时不在等待，该任务执行完成返回</span><br><span class="line">    dispatch_semaphore_wait(semaphore2, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    //当监控得到追加队列里的任务都完成后，调用本 block 任务</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        //当获取全部数据后，在主线程进行刷新页面</span><br><span class="line">        NSString *image1 = [images firstObject];</span><br><span class="line">        if (image1 &amp;&amp; [image1 isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            self.imageView1.image = [[UIImage alloc] initWithContentsOfFile:image1];;</span><br><span class="line">        &#125;</span><br><span class="line">        NSString *image2 = [images lastObject];</span><br><span class="line">        if (image2 &amp;&amp; [image2 isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            self.imageView2.image = [[UIImage alloc] initWithContentsOfFile:image2];;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h4 id="8、dispatch-once"><a href="#8、dispatch-once" class="headerlink" title="8、dispatch_once"></a>8、dispatch_once</h4><p>dispatch_once 函数时保证在应用程序执行中只执行一次指定处理的 API。<br>经常用在生成单例对象的时候。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    // code to be executed once</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://objccn.io/issue-2-3/">底层并发 API</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NKupCS1RsAGhbzhCpYl2mA">iOS 如何高效的使用多线程</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/39d6edb54d24">深入浅出 iOS 并发编程</a></p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2026 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>